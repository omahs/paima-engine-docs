"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[3052],{520:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>h});var n=i(5893),a=i(1151);const s={},o="L2 Block structure",r={id:"home/state-machine/structure",title:"L2 Block structure",description:"Rollups built with Paima Engine, similar to other blockchains, consist of blocks that contain transactions inside them. The key difference is that unlike typical chains, data that forms Paima blocks comes from underlying sources or deterministic self-defined transitions as opposed to user inputs intrinstic to the system itself.",source:"@site/docs/home/100-state-machine/1000-structure.md",sourceDirName:"home/100-state-machine",slug:"/home/state-machine/structure",permalink:"/home/state-machine/structure",draft:!1,unlisted:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-state-machine/1000-structure.md",tags:[],version:"current",sidebarPosition:1e3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Setup",permalink:"/home/state-machine/creating-events/precompiles/introduction"},next:{title:"Basic Concepts",permalink:"/home/game-node-api/introduction"}},c={},h=[{value:"Transaction hash",id:"transaction-hash",level:2},{value:"Decision 1) No Merklization of inputs",id:"decision-1-no-merklization-of-inputs",level:3},{value:"Decision 2) Failed transactions affect the block hash",id:"decision-2-failed-transactions-affect-the-block-hash",level:3},{value:"Decision 3) primitives that do not trigger an STF do not modify the block hash for that block",id:"decision-3-primitives-that-do-not-trigger-an-stf-do-not-modify-the-block-hash-for-that-block",level:3},{value:"Decision 4) There is no genesis hash",id:"decision-4-there-is-no-genesis-hash",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"l2-block-structure",children:"L2 Block structure"}),"\n",(0,n.jsxs)(t.p,{children:["Rollups built with Paima Engine, similar to other blockchains, consist of blocks that contain transactions inside them. The key difference is that unlike typical chains, data that forms Paima blocks comes from ",(0,n.jsx)(t.a,{href:"/home/state-machine/react-to-events/funnel-types/common-concepts/intro",children:"underlying sources"})," or ",(0,n.jsx)(t.a,{href:"/home/state-machine/creating-events/timers-ticks",children:"deterministic self-defined transitions"})," as opposed to user inputs intrinstic to the system itself."]}),"\n",(0,n.jsxs)(t.p,{children:["Paima-based rollups, unlike many chains, does not ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Merkle_tree",children:"Merklize"})," its state, as this comes with a ",(0,n.jsx)(t.a,{href:"https://sovereign.mirror.xyz/jfx_cJ_15saejG9ZuQWjnGnG-NfahbazQH98i1J3NN8",children:"significant performance overhead"}),". Paima is not alone in doing this - this is done by other successful systems like ",(0,n.jsx)(t.a,{href:"https://solana.com/",children:"Solana"})," as well."]}),"\n",(0,n.jsx)(t.h2,{id:"transaction-hash",children:"Transaction hash"}),"\n",(0,n.jsx)(t.p,{children:"Knowing the transaction hash is crucial to be able to reference the state and information about a given transaction on the rollup."}),"\n",(0,n.jsx)(t.p,{children:"Note there are a few key properties we want to get from our hash function:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"client-side computable"}),": transaction hashes should be computable locally before it actually gets included inside a block. This helps write tools where you can query the status of the transaction before it gets included in a block."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"low memory requirement"}),": transaction hashes must be computable with small amounts of memory (ex: we never hash a giant blob of data. For anything that has a large amount of data, we first hash of the data (to turn it into a small string), and then past this has to the tx hash function). This is useful to make sure that transaction hashes can be calculated on devices with limited memory (ex: hardware wallets)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"avoid user injection"}),": transaction hashes never take in directly user-specified inputs (always hash things that users have control over) to avoid any chance of users injecting things that break parsers"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"There are a few tricky parts to computing transaction hashes in Paima-based rollups:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Differentiating similar events in different chains"}),": since transactions in Paima often come from an underlying chain, we heavily leverage ",(0,n.jsx)(t.a,{href:"https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md",children:"caip-2"})," which is a standard to give unique IDs for every chain. This means that two identical transactions submitted on different chains, even if they have the exact same content, will result in a different transaction hash."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Flattening events"}),": in chains like Ethereum, one transaction may (and in fact often do) trigger multiple events. Since Paima rollups considers these events each individual transactions, it means one transaction on the underlying chain may trigger multiple transactions in a rollup. To tackle this, we give a unique incrementing ID to each event triggered from the same transaction (",(0,n.jsx)(t.code,{children:"indexForEvent"}),") so that they all get a different final tx hash."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Timers IDs"}),": Some transactions may be initiated by ",(0,n.jsx)(t.a,{href:"/home/state-machine/creating-events/timers-ticks",children:"timers"}),". We differentiate timers with ",(0,n.jsx)(t.a,{href:"/home/state-machine/creating-events/precompiles/introduction",children:"precompiles"}),', but the same timer can produce the same data (ex: "reset daily leaderboard") many times, and could even generate multiple identical events in the same block. To tackle this, we include both the block number where the timer is expected to trigger as well as a unique incrementing ID to each event triggered from the same tune (',(0,n.jsx)(t.code,{children:"indexForEvent"}),") so that they all get a different final tx hash."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Separating elements"}),": Since Paima transaction hashes need to combine multiple different inputs of different length, we use a separator ",(0,n.jsx)(t.code,{children:"|"})," to separate the field."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"To calculate a transaction hash, there two cases that need to be handled:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["For ",(0,n.jsx)(t.a,{href:"/home/state-machine/react-to-events/primitive-catalogue/introduction",children:"for primitives"})," / ",(0,n.jsx)(t.a,{href:"/home/state-machine/direct-write/write-data",children:"direct user transactions"}),","]}),"\n"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"keccak_256(\n  caip2Prefix |\n  origin_tx_hash |\n  indexForEvent(origin_tx_hash) // to handle the fact one tx hash on the origin chain can trigger multiple STF updates on the rollup\n)\n"})}),"\n",(0,n.jsxs)(t.ol,{start:"2",children:["\n",(0,n.jsxs)(t.li,{children:["For ",(0,n.jsx)(t.a,{href:"/home/state-machine/creating-events/timers-ticks",children:"timers"}),","]}),"\n"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"keccak_256(\n  userAddress |\n  keccak_256(input_data) |\n  scheduledBlockHeight |\n  timerIndexRelativeToBlock // to handle the fact the same timer can trigger multiple times in the same block\n),\n"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"\n## Blocks\n\nPaima blocks have the following data type available as both `PreExecutionBlockHeader` and `PostExecutionBlockHeader` as part of `@paima/chain-types`\n\n```ts\n{\n  version: 1;   \n  mainChainBlochHash: string;\n  blockHeight: number;\n  prevBlockHash: string | null;\n  msTimestamp: number;\n  successTxsHash: string;\n  failedTxsHash: string;\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Notably, all transactions that trigger STF calls affects the block hash (which is a keccack hash of a ",(0,n.jsx)(t.code,{children:"|"}),"-separated combination of the above-mentioned fields. See ",(0,n.jsx)(t.code,{children:"hashBlock"})," in ",(0,n.jsx)(t.code,{children:"@paima/chain-types"})," for more)"]}),"\n",(0,n.jsx)(t.p,{children:"Paima blocks follow a few key design decisions"}),"\n",(0,n.jsx)(t.h3,{id:"decision-1-no-merklization-of-inputs",children:"Decision 1) No Merklization of inputs"}),"\n",(0,n.jsxs)(t.p,{children:["Typically, blocks contain a Merkle root of the inputs within a block, as it allows you to prove including of a transaction within a block in logarithm space/time. However, Merklization also has a performance cost, so it should only be used when needed. You can find the performance rationale for this decision ",(0,n.jsx)(t.a,{href:"https://github.com/PaimaStudios/paima-engine/pull/423",children:"here"})]}),"\n",(0,n.jsx)(t.p,{children:"The key points are that:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Merklization (especially in JS) is slow"}),"\n",(0,n.jsx)(t.li,{children:"Checking if an input is part of a block's Merkle tree is not a common action, and if really needed you can check if the input is contained in the relevant underlying chain instead of querying this information through Paima"}),"\n",(0,n.jsx)(t.li,{children:"The fact that Merklization is used doesn't give a large benefit when it comes to techniques like storage proofs (ZK)"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"decision-2-failed-transactions-affect-the-block-hash",children:"Decision 2) Failed transactions affect the block hash"}),"\n",(0,n.jsx)(t.p,{children:"Failed transactions here refers to any transaction that made it all the way to an STF call, and then failed during the STF comptuation itself. Storing these is useful for debugging, and they do not present a trivial DOS vector as these transactions are triggered by actions on the underlying chain (which have gas costs) or things like timers (which the app developer controls)."}),"\n",(0,n.jsx)(t.h3,{id:"decision-3-primitives-that-do-not-trigger-an-stf-do-not-modify-the-block-hash-for-that-block",children:"Decision 3) primitives that do not trigger an STF do not modify the block hash for that block"}),"\n",(0,n.jsx)(t.p,{children:'Implicit state (that do not come from explicit user inputs) typically do not modify the block hash as an industry convention (ex: many chains have implicit state like "staking rewards" that accumulate over time without being reflected in the block hash)'}),"\n",(0,n.jsxs)(t.p,{children:["You can learn more about how this works in relation to primitives ",(0,n.jsx)(t.a,{href:"/home/state-machine/react-to-events/primitive-catalogue/introduction#accessing-the-collected-data",children:"here"})]}),"\n",(0,n.jsx)(t.h3,{id:"decision-4-there-is-no-genesis-hash",children:"Decision 4) There is no genesis hash"}),"\n",(0,n.jsxs)(t.p,{children:['Typically, chains have a "genesis block". However, in Paima, it\'s not clear what the "genesis" hash would refer to in a generic way. You can find a discussion on this point ',(0,n.jsx)(t.a,{href:"https://github.com/PaimaStudios/paima-engine/issues/424",children:"here"})]})]})}function d(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},1151:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>o});var n=i(7294);const a={},s=n.createContext(a);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);