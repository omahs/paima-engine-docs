"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[109],{4793:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=n(5893),i=n(1151);const o={},s="EVM Block Funnel",r={id:"home/state-machine/react-to-events/funnel-types/block-funnel",title:"EVM Block Funnel",description:"Block funnel is the most standard funnel type in Paima. It simply downloads the blocks from the RPC provider for the chain you are deploying to.",source:"@site/docs/home/100-state-machine/300-react-to-events/3-funnel-types/300-block-funnel.md",sourceDirName:"home/100-state-machine/300-react-to-events/3-funnel-types",slug:"/home/state-machine/react-to-events/funnel-types/block-funnel",permalink:"/ja/home/state-machine/react-to-events/funnel-types/block-funnel",draft:!1,unlisted:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-state-machine/300-react-to-events/3-funnel-types/300-block-funnel.md",tags:[],version:"current",sidebarPosition:300,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Configuring your Funnel",permalink:"/ja/home/state-machine/react-to-events/funnel-types/configuration"},next:{title:"EVM Parallel funnel",permalink:"/ja/home/state-machine/react-to-events/funnel-types/parallel-evm-funnel"}},l={},c=[{value:"Configuration",id:"configuration",level:2},{value:"Conceptually",id:"conceptually",level:2},{value:"Fetching more than just logs",id:"fetching-more-than-just-logs",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"evm-block-funnel",children:"EVM Block Funnel"}),"\n",(0,a.jsx)(t.p,{children:"Block funnel is the most standard funnel type in Paima. It simply downloads the blocks from the RPC provider for the chain you are deploying to."}),"\n",(0,a.jsx)(t.h2,{id:"configuration",children:"Configuration"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"Hardhat1:\n  type: evm-main\n  chainUri: 'http://localhost:8545'\n  chainId: 31337\n  chainCurrencyName: 'Test Hardhat Tokens'\n  chainCurrencySymbol: 'TEST'\n  chainCurrencyDecimals: 18\n  blockTime: 2\n  paimaL2ContractAddress: '0x5FbDB2315678afecb367f032d93F642f64180aa3'\n"})}),"\n",(0,a.jsx)(t.h2,{id:"conceptually",children:"Conceptually"}),"\n",(0,a.jsx)(t.p,{children:"Notably, block funnel will do the following:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["Get the latest block number using ",(0,a.jsx)(t.code,{children:"eth_blockNumber"})," so we know how far we are from the tip, and cache it to ",(0,a.jsx)(t.code,{children:"latestAvailableBlockNumber"})]}),"\n",(0,a.jsxs)(t.li,{children:["Fetch a group of ",(0,a.jsx)(t.code,{children:"DEFAULT_FUNNEL_GROUP_SIZE"})," blocks (or less if we're already at the tip)"]}),"\n",(0,a.jsxs)(t.li,{children:["Fetch any ",(0,a.jsx)(t.a,{href:"/ja/home/state-machine/react-to-events/primitive-catalogue/evm/dynamic-primitives",children:"dynamic primitive"})," that needs to be registered"]}),"\n",(0,a.jsxs)(t.li,{children:["Fetch all the block numbers needed in parallel using ",(0,a.jsx)(t.code,{children:"eth_getBlockByNumber"})]}),"\n",(0,a.jsxs)(t.li,{children:["Fetch all the ",(0,a.jsx)(t.code,{children:"PaimaGameInteraction"})," Solidity events for the block range using ",(0,a.jsx)(t.code,{children:"eth_getLogs"})]}),"\n",(0,a.jsxs)(t.li,{children:["Fetch all the ",(0,a.jsx)(t.a,{href:"/ja/home/state-machine/react-to-events/primitive-catalogue/introduction",children:"Primitives"})," for the block range using ",(0,a.jsx)(t.code,{children:"eth_getLogs"})]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Here is a visual representation of the flow:"}),"\n",(0,a.jsx)(t.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e RequestBlockNumber\n    \n    RequestBlockNumber: Request latest block number (<i>eth_blockNumber</i>)\n\n    DynamicPrimitives: Get dynamic primitive updates (<i>eth_getLogs</i>)\n    RequestBlockNumber --\x3e DynamicPrimitives\n    \n    fork_state: fetch remote data for the next group of block numbers\n    DynamicPrimitives --\x3e fork_state\n    state fork_state <<fork>>\n\n    GetBlock: Get block (<i>eth_getBlockByNumber</i>)\n\n    GetLogs: Get logs for primitives (<i>eth_getLogs</i>)\n\n    fork_state --\x3e GetBlock\n    fork_state --\x3e GetLogs\n    \n    join_state: merge data together\n    state join_state <<join>>\n    \n    GetBlock --\x3e join_state\n    GetLogs --\x3e join_state\n    \n    join_state --\x3e ProcessData\n    \n    ProcessData: Decode block data into rollup data format\n\n    ProcessData --\x3e FeedDataToSM\n    \n    FeedDataToSM: Feed data to user-specified state machine\n    \n    FeedDataToSM --\x3e [*]"}),"\n",(0,a.jsx)(t.h2,{id:"fetching-more-than-just-logs",children:"Fetching more than just logs"}),"\n",(0,a.jsxs)(t.p,{children:["Note that all the primitives for this funnel are based on ",(0,a.jsx)(t.code,{children:"eth_getLogs"}),". That is to say, there is no way to access data outside of these events provided by the funnel itself. If you need this functionality, there are a way few ways that it can be achieved:"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["Use ",(0,a.jsx)(t.code,{children:"eth_call"})," in your state machine once your state transition function gets triggered by an event. You can use this to read from contract storage. ",(0,a.jsx)(t.strong,{children:"Note"}),": when doing this, be sure to specify the block height for the call to make sure it matches the same block height of your STF call, otherwise this will not be deterministic. Be careful if this event comes from a different chain than your main chain (see ",(0,a.jsx)(t.a,{href:"https://github.com/PaimaStudios/paima-engine/issues/412",children:"this issue"})," for more)","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Benefit"}),": Conceptually simple"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Drawback"}),": ",(0,a.jsx)(t.code,{children:"eth_call"})," only support getting the state of a contract ",(0,a.jsx)(t.em,{children:"after"})," all transactions in that block have been processed. This means that if multiple transactions interact with your dApp in the same block, the data may not longer match the state when the event happened."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["Use ",(0,a.jsx)(t.code,{children:"debug_traceTransaction"})," in your state machine once your state transition function gets triggered by an event. When run in ",(0,a.jsx)(t.code,{children:"prestateTracer"})," mode, it can tell you the storage modified by a specific transaction. You can use ",(0,a.jsx)(t.code,{children:"eth_getStorageAt"})," to get the initial storage state of the contract, then repeatedly apply ",(0,a.jsx)(t.code,{children:"debug_traceTransaction"})," all the way until you et to the desired transaction hash.","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Benefit"}),": Gets you the exact state when for the transaction where the event was emitted"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Drawback"}),": It's extremely hard to reason about the correctness of this approach (How do you simulate the transaction up to the exact point when the event was emitted if you need that? What if the event gets emitted twice in the same transaction? What if the event or contract occurs multiple times in the transaction (see: internal transactions)). It is also heavy, as it requires not only multiple RPC calls, but also because some of these RPC calls return large data payloads."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["(if you can modify the contract) simply modify your event to include any information you need","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Benefit"}),": Conceptually simple"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Drawback"}),": It may not be possible if your contract is already live. Additionally, logging more data increases the gas cost."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["(if you can't modify the contract) sse a separate tool like ",(0,a.jsx)(t.a,{href:"%60https://www.shadow.xyz/%60",children:"Shadow"})," to simulate modifying the logs emitted by the contract","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Benefit"}),": Allows you to modify the events to get the data you need, even if your contract is already live"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Drawback"}),": Introduces a dependency on an external company"]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>s});var a=n(7294);const i={},o=a.createContext(i);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);