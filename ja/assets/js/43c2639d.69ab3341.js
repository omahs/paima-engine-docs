"use strict";(self.webpackChunkpaima_engine_docs=self.webpackChunkpaima_engine_docs||[]).push([[109],{4793:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var s=n(5893),i=n(1151);const o={},a="Block Funnel",l={id:"home/state-machine/react-to-events/funnel-types/block-funnel",title:"Block Funnel",description:"Block funnel is the most standard funnel type in Paima. It simply downloads the blocks from the RPC provider for the chain you are deploying to.",source:"@site/docs/home/100-state-machine/300-react-to-events/3-funnel-types/300-block-funnel.md",sourceDirName:"home/100-state-machine/300-react-to-events/3-funnel-types",slug:"/home/state-machine/react-to-events/funnel-types/block-funnel",permalink:"/ja/home/state-machine/react-to-events/funnel-types/block-funnel",draft:!1,unlisted:!1,editUrl:"https://github.com/PaimaStudios/paima-engine-docs/tree/main/docs/home/100-state-machine/300-react-to-events/3-funnel-types/300-block-funnel.md",tags:[],version:"current",sidebarPosition:300,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Configuring your Funnel",permalink:"/ja/home/state-machine/react-to-events/funnel-types/configuration"},next:{title:"Emulated Block Funnel (Stable Ticks)",permalink:"/ja/home/state-machine/react-to-events/funnel-types/stable-tick-rate-funnel"}},r={},c=[{value:"Fetching more than just logs",id:"fetching-more-than-just-logs",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"block-funnel",children:"Block Funnel"}),"\n",(0,s.jsx)(t.p,{children:"Block funnel is the most standard funnel type in Paima. It simply downloads the blocks from the RPC provider for the chain you are deploying to."}),"\n",(0,s.jsx)(t.p,{children:"Notably, block funnel will do the following:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Get the latest block number using ",(0,s.jsx)(t.code,{children:"eth_blockNumber"})," so we know how far we are from the tip, and cache it to ",(0,s.jsx)(t.code,{children:"latestAvailableBlockNumber"})]}),"\n",(0,s.jsxs)(t.li,{children:["Fetch a group of ",(0,s.jsx)(t.code,{children:"DEFAULT_FUNNEL_GROUP_SIZE"})," blocks (or less if we're already at the tip)"]}),"\n",(0,s.jsxs)(t.li,{children:["Fetch all the block numbers needed in parallel using ",(0,s.jsx)(t.code,{children:"eth_getBlockByNumber"})]}),"\n",(0,s.jsxs)(t.li,{children:["Fetch all the ",(0,s.jsx)(t.code,{children:"PaimaGameInteraction"})," Solidity events for the block range using ",(0,s.jsx)(t.code,{children:"eth_getLogs"})]}),"\n",(0,s.jsxs)(t.li,{children:["Fetch all the ",(0,s.jsx)(t.a,{href:"/ja/home/state-machine/react-to-events/primitive-catalogue/introduction",children:"Primitives"})," for the block range using ",(0,s.jsx)(t.code,{children:"eth_getLogs"})]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"fetching-more-than-just-logs",children:"Fetching more than just logs"}),"\n",(0,s.jsxs)(t.p,{children:["Note that all the primitives for this funnel are based on ",(0,s.jsx)(t.code,{children:"eth_getLogs"}),". That is to say, there is no way to access data outside of these events provided by the funnel itself. If you need this functionality, there are a way few ways that it can be achieved:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Use ",(0,s.jsx)(t.code,{children:"eth_call"})," in your state machine once your state transition function gets triggered by an event. You can use this to read from contract storage. ",(0,s.jsx)(t.strong,{children:"Note"}),": when doing this, be sure to specify the block height for the call to make sure it matches the same block height of your STF call, otherwise this will not be deterministic. Be careful if this event comes from a different chain than your main chain (see ",(0,s.jsx)(t.a,{href:"https://github.com/PaimaStudios/paima-engine/issues/412",children:"this issue"})," for more)","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Benefit"}),": Conceptually simple"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Drawback"}),": ",(0,s.jsx)(t.code,{children:"eth_call"})," only support getting the state of a contract ",(0,s.jsx)(t.em,{children:"after"})," all transactions in that block have been processed. This means that if multiple transactions interact with your dApp in the same block, the data may not longer match the state when the event happened."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["Use ",(0,s.jsx)(t.code,{children:"debug_traceTransaction"})," in your state machine once your state transition function gets triggered by an event. When run in ",(0,s.jsx)(t.code,{children:"prestateTracer"})," mode, it can tell you the storage modified by a specific transaction. You can use ",(0,s.jsx)(t.code,{children:"eth_getStorageAt"})," to get the initial storage state of the contract, then repeatedly apply ",(0,s.jsx)(t.code,{children:"debug_traceTransaction"})," all the way until you et to the desired transaction hash.","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Benefit"}),": Gets you the exact state when for the transaction where the event was emitted"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Drawback"}),": It's extremely hard to reason about (what if the event get emitted twice in the same transaction? Possibly during different internal transactions?). It is also heavy as it require not only multiple RPC calls, but also because some of these RPC calls return large data payloads."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["(if you can modify the contract) simply modify your event to include any information you need","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Benefit"}),": Conceptually simple"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Drawback"}),": It may not be possible if your contract is already live. Additionally, logging more data increases the gas cost."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["(if you can't modify the contract) sse a separate tool like ",(0,s.jsx)(t.a,{href:"%60https://www.shadow.xyz/%60",children:"Shadow"})," to simulate modifying the logs emitted by the contract","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Benefit"}),": Allows you to modify the events to get the data you need, even if your contract is already live"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Drawback"}),": Introduces a dependency on an external company"]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>a});var s=n(7294);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);