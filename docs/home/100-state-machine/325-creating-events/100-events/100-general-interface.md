# General Interface

Events are defined by two components:
1. A `name`, which must be unique in your app
1. A set of `fields` which defines the event content. Fields are made up of
    1. A `name` for a *positional argument*
    2. A `type` defined with [typebox](https://github.com/sinclairzx81/typebox) to ensure JSON compatibility
    3. A `indexed` boolean for whether or not events will be [indexable](https://en.wikipedia.org/wiki/Database_index) on this field. One index per field will be created on the underlying table.

Here is an example of an event that tracks completing quests in a game. In this example, we create an `index` on the `playerId` so a client could get realtime updates whenever a user has completing a quest.

```typescript
import { Type } from '@sinclair/typebox';
import { genEvent } from './types.js';

const QuestCompletionEvent = genEvent({
  name: 'QuestCompletion',
  fields: [
    {
      name: 'playerId',
      type: Type.Integer(),
      indexed: true,
    },
    {
      name: 'questId',
      type: Type.Integer(),
    },
  ],
} as const);
```

# Register app events

In order for Paima Engine to be able to use the events, these need to be
exported through a module in the packaged files. This can be generated by having
an `events` package in the game's directory, where the result of
`registerEvents` is exported:

```ts
const eventDefinitions = {
  QuestCompletionEvent,
} as const;

export const events = registerEvents(eventDefinitions);
```

# Listening to events

You can listen to these events easily from Javascript just by importing the event definition

A few things to note:
1. You can `filter` events based on the `indexed` fields. Filtering is optional, and you can filter by any set (or subset) of `indexed` fields of the event
2. You can register multiple subscribers to the *same* event. Paima Engine will handle [multiplexing](https://en.wikipedia.org/wiki/Multiplexing) under the hood so that subscriptions with the same `event+filter` combination do not cause duplicate network requests
3. You can call the `unsubscribe` response at any time to lower the number of open connections you have

```ts
import { PaimaEventManager } from '@paima/sdk/events';
import { events } from '@game/events';

const suscriptionHandle = await PaimaEventManager.Instance.subscribe(
  {
    topic: events.QuestCompletionEvent,
    filter: { playerId: undefined }, // all players
  },
  event => {
    console.log(`Quest ${event.questId} cleared by ${event.playerId}`);
  }
);

// later
await PaimaEventManager.Instance.unsubscribe(suscriptionHandle);
```

# Posting new events

You can publish messages from your game's state machine at any time. You need to
provide *all* fields (both those indexed and those that aren't). This is done by
returning the new events as a part of the state transition function's result,
alongside the SQL queries that change the state. If all the changes to the
database state are applied correctly for that transaction, then Paima Engine
will take care of sending these events *only* to the clients that need them.
Under the hood, the engine uses the following API for this.

```ts
import { PaimaEventManager } from '@paima/sdk/events';

await PaimaEventListener.Instance.sendMessage(QuestCompletionEvent, { questId: 5, playerId: 10 });
```

## State transition function

From Paima Engine's point of view, the type of the `stateTransitionFunction`
looks something like this.

```ts
async function stateTransitionFunction (
  inputData: SubmittedChainData,
  header: { blockHeight: number; timestamp: number },
  randomnessGenerator: Prando,
  dbConn: Pool
): Promise<{
  stateTransitions: SQLUpdate[];
  events: {
    address: `0x${string}`;
    data: {
      name: string;
      fields: { [fieldName:string]: any };
      topic: string;
    };
  }[];
}>;
```

Since the event definitions are loaded at runtime, there is no way for it
to narrow the type of the events.

Then the most straightforward way of emitting events from the stf would be this:

```ts
return {
  stateTransitions: [],
  events: [
    {
      address: precompiles.foo,
      data: {
        name: QuestCompletion.name,
        fields: {
          questId: 5,
          playerId: 10,
        },
        topic: toSignatureHash(QuestCompletion),
      },
    },
  ],
};
```

However, this doesn't leverage the typescript's type system at all, which makes
it error prone.

## Typed helpers

Instead, the recommended approach is to use the typed helpers provided in the
SDK.

The first one is the `EventQueue` type, which can be used to statically
guarantee that the emitted events are part of the exported events. For example:

```ts
type Events = EventQueue<typeof eventDefinitions>;

async function stateTransitionFunction (
  inputData: SubmittedChainData,
  header: { blockHeight: number; timestamp: number },
  randomnessGenerator: Prando,
  dbConn: Pool
): Promise<{
  stateTransitions: SQLUpdate[];
  events: Events;
}>;
```

This prevents you from emitting events that are not part of the
`eventDefinitions` object.

The second helper is the `encodeEventForStf` function, which can be used to
rewrite the previous code like this:

```ts
import { events } from '@game/events';
return {
  stateTransitions: [],
  events: [
    encodeEventForStf({
      from: precompiles.foo,
      topic: events.QuestCompletion,
      data: {
        questId: 5,
        playerId: 10,
      },
    }),
  ],
};
```

The main reason to use this function is to ensure that the signature hash
matches the event type through encapsulation. The easiest way to make this
mistake would be when there are overloaded events.

For example, if there was another registered event with this definition:

```ts
const QuestCompletionEvent_v2 = genEvent({
  name: 'QuestCompletion',
  fields: [
    {
      name: 'playerId',
      type: Type.Integer(),
      indexed: true,
    },
    {
      name: 'questId',
      type: Type.Integer(),
    },
    {
      name: 'points',
      type: Type.Integer(),
    },
  ],
} as const);
```

Then the following event will typecheck, but the topic will be incorrect, since
it has a different signature.

```ts
return {
  stateTransitions: [],
  events: [
    {
      address: precompiles.foo,
      data: {
        name: QuestCompletion.name,
        fields: {
          questId: 5,
          playerId: 10,
          points: 20
        },
        topic: toSignatureHash(QuestCompletion),
      },
    },
  ],
};
```

Using `encodeEventForStf` also has the secondary advantage of providing better
error messages and editor support, particularly with overloaded events, since
once the topic argument is fixed, the type of the data can be fully computed
instead of having to compare to the full union of possible values.

# Signature hash

A unique identifier is computed for each app defined event. This can be computed
with the `toSignatureHash` function.

```ts
const questCompletion = toSignatureHash(QuestCompletionEvent);
```

The way this works is that the signature is first encoded as text:

`QuestCompletion(integer,integer)`

And then hashed with keccak_256 to get the identifier:

`3e3198e308aafca217c68bc72b3adcc82aa03160ef5e9e7b97e1d4afa8f792d5`

This gets stored in the database on startup, and it's used to check that no
events are removed (or modified). Note that this doesn't take into account
whether the fields are indexed or not.